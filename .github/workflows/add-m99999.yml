# Этот workflow при ручном запуске создаст ветку feature/m99999-module и добавит файлы модуля.
# Просмотрите содержимое перед запуском. После успешного пуша вы можете удалить этот workflow.
name: Add m99999 module

on:
  workflow_dispatch:

jobs:
  add-module:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "komyaka-bot"
          git config user.email "komyaka@users.noreply.github.com"

      - name: Create branch
        run: |
          git checkout -b feature/m99999-module

      - name: Add module_99999.c
        run: |
          cat > src/modules/module_99999.c <<'EOF'
/* module_99999.c
 *
 * Модуль Ethereum brainwallet (m99999) — исправленная версия
 *
 * Комментарии и сообщения — на русском языке.
 *
 * Изменения:
 * - KERN_FILE_A0/A3 по умолчанию указывают на m99999_a0-pure.cl / m99999_a3-pure.cl
 * - Безопасный вызов hex_to_bytes: копируем 40 символов в локальный буфер и завершаем NUL
 * - cmp_hash использует DGST_SIZE * 4 вместо "магического" 20
 * - binary_to_hex корректно ставит '\0' даже при длине 0
 *
 * Предположения:
 * - hex_to_bytes, макросы (DIGEST_M0, PARSER_OK, ...) и функции log_error/module_register
 *   присутствуют в окружении сборки (как в кодовой базе hashcat).
 */

#include "common.h"
#include "types.h"
#include "modules.h"
#include "logging.h"
#include "memory.h"
#include "event.h"
#include "thread.h"
#include "backend.h"

#include <string.h>
#include <ctype.h>
#include <stdint.h>

/* Имена файлов ядра по умолчанию (подставьте свои, если в репозитории -- другие) */
#ifndef KERN_FILE_A0
#define KERN_FILE_A0 "m99999_a0-pure.cl"
#endif

#ifndef KERN_FILE_A3
#define KERN_FILE_A3 "m99999_a3-pure.cl"
#endif

#ifndef DGST_SIZE
/* 5 u32s (20 bytes) */
#define DGST_SIZE 5
#endif

/* Вспомогательные функции -------------------------------------------------- */

/* конвертирует 20 байт -> 5 u32 (младший порядок байт — LE) */
static void addr_u8_to_u32_LE (const u8 *in, u32 *out)
{
  for (int i = 0; i < 5; i++)
  {
    const int off = i * 4;
    out[i] = (u32) in[off + 0]
           | ((u32) in[off + 1] << 8)
           | ((u32) in[off + 2] << 16)
           | ((u32) in[off + 3] << 24);
  }
}

/* конвертирует 5 u32 (LE) -> 20 байт */
static void addr_u32_to_u8_LE (const u32 *in, u8 *out)
{
  for (int i = 0; i < 5; i++)
  {
    const u32 v = in[i];
    const int off = i * 4;
    out[off + 0] = (u8) (v & 0xff);
    out[off + 1] = (u8) ((v >> 8) & 0xff);
    out[off + 2] = (u8) ((v >> 16) & 0xff);
    out[off + 3] = (u8) ((v >> 24) & 0xff);
  }
}

/* bytes -> lowercase hex (не записывает завершающий NUL).
   Возвращает число записанных символов (len*2) или -1 при ошибке размера. */
static int bytes_to_hex_lower (const u8 *bytes, int len, char *hex_output, int out_size)
{
  static const char hexmap[] = "0123456789abcdef";

  if (out_size < (len * 2)) return -1;

  for (int i = 0; i < len; i++)
  {
    const u8 b = bytes[i];
    hex_output[i * 2 + 0] = hexmap[(b >> 4) & 0xF];
    hex_output[i * 2 + 1] = hexmap[b & 0xF];
  }

  return len * 2;
}

/* Парсер: принимает 40 hex символов или 42 с префиксом 0x/0X */
static int parse_hash (hashcat_ctx_t *hashcat_ctx, void *digest_buf, const char *line_buf, const int line_len)
{
  (void) hashcat_ctx;

  u32 *digests_buf = ((u32 *) digest_buf) + DIGEST_M0;

  if (line_buf == NULL)
  {
    log_error ("Ошибка: NULL указатель line_buf");
    return PARSER_HASH_LENGTH;
  }

  /* Обрезаем CR/LF в конце */
  int line_len_real = line_len;
  while (line_len_real > 0)
  {
    const char c = line_buf[line_len_real - 1];
    if ((c == '\n') || (c == '\r')) line_len_real--;
    else break;
  }

  if ((line_len_real != 40) && (line_len_real != 42))
  {
    log_error ("Ошибка: неверная длина входной строки (ожидается 40 или 42 символа)");
    return PARSER_HASH_LENGTH;
  }

  const char *hash_str = line_buf;
  int hash_len = line_len_real;

  if ((hash_len == 42) && (hash_str[0] == '0') && (hash_str[1] == 'x' || hash_str[1] == 'X'))
  {
    hash_str += 2;
    hash_len -= 2;
  }

  if (hash_len != 40)
  {
    log_error ("Ошибка: неверная длина хеша после опционального 0x (ожидается 40 символов)");
    return PARSER_HASH_LENGTH;
  }

  u8 addr[20] = { 0 };

  /* Безопасный вызов hex_to_bytes: копируем 40 символов в локальный буфер и NUL-терминируем */
  {
    char tmp[41];
    memcpy (tmp, hash_str, 40);
    tmp[40] = '\0';

    /* hex_to_bytes должен быть доступен в окружении сборки.
       Ожидаем сигнатуру: int hex_to_bytes(const char *hex, int hex_len, u8 *out, u32 *out_len)
       Если ваша версия принимает иначе — отредактируйте здесь. */
    if (hex_to_bytes (tmp, 40, addr, NULL) == -1)
    {
      log_error ("Ошибка: недопустимые hex-символы в хеше");
      return PARSER_HASH_ENCODING;
    }
  }

  addr_u8_to_u32_LE (addr, digests_buf);

  return PARSER_OK;
}

/* Сравнение двух digest-буферов (20 байт в позиции DIGEST_M0) */
static int cmp_hash (void *digest_buf1, void *digest_buf2)
{
  const u32 *d1 = ((const u32 *) digest_buf1) + DIGEST_M0;
  const u32 *d2 = ((const u32 *) digest_buf2) + DIGEST_M0;

  /* сравниваем DGST_SIZE * 4 байт */
  return memcmp (d1, d2, DGST_SIZE * 4);
}

/* Кодируем digest -> "0x" + 40 hex символов (строчные) */
static int hash_to_binary (void *digest_buf, char *line_buf, const int line_size, const int hash_encoding)
{
  (void) hash_encoding;

  if (line_buf == NULL) return 0;

  const u32 *digests_buf = ((const u32 *) digest_buf) + DIGEST_M0;

  u8 addr[20];
  addr_u32_to_u8_LE (digests_buf, addr);

  const int needed = 2 + 40; /* "0x" + 40 hex chars */
  if (line_size < (needed + 1)) /* +1 для завершающего NUL */
  {
    log_error ("Ошибка: буфер вывода слишком мал в hash_to_binary");
    return 0;
  }

  line_buf[0] = '0';
  line_buf[1] = 'x';

  if (bytes_to_hex_lower (addr, 20, line_buf + 2, 40) != 40)
  {
    log_error ("Ошибка: конвертация в hex в hash_to_binary завершилась неудачей");
    return 0;
  }

  line_buf[2 + 40] = '\0';

  return needed; /* 42 */
}

/* Преобразование произвольного бинарного digest в hex строку (строчные).
   Функция ставит завершающий NUL. */
static void binary_to_hex (u8 *digest, char *hex_output, const int digest_len)
{
  if ((digest == NULL) || (hex_output == NULL) || (digest_len < 0)) return;

  int rc = bytes_to_hex_lower (digest, digest_len, hex_output, digest_len * 2);
  if (rc >= 0) hex_output[rc] = '\0';
}

/* Инициализация ядра (специальных действий не требуется) */
static void init_kernel (hashcat_ctx_t *hashcat_ctx, const u32 algo, const u32 opti_type)
{
  (void) hashcat_ctx;
  (void) algo;
  (void) opti_type;
}

/* Инициализация module context */
static void module_init (module_ctx_t *module_ctx)
{
  module_ctx->module_name = MODULE_NAME;
  module_ctx->short_module_desc = "Ethereum Brainwallet (SHA256 + secp256k1 + Keccak)";
  module_ctx->long_module_desc = "Cracks Ethereum addresses from brainwallets using SHA256(priv) -> secp256k1 pubkey -> Keccak256(pub[1:])[-20:]";

  module_ctx->supported_hash_types = SUPPORTED_TYPE;

  /* Запуск работы внутри ядра (важно для производительности GPU) */
  module_ctx->attack_exec = ATTACK_EXEC_INSIDE_KERNEL;

  /* Настройки связки с ядрами */
  module_ctx->kern_type = 1;            /* при необходимости замените макросом вашей сборки */
  module_ctx->dgst_size = DGST_SIZE;    /* размер digest в u32 (5) */
  module_ctx->a0_file = KERN_FILE_A0;   /* файл ядра для a0 */
  module_ctx->a3_file = KERN_FILE_A3;   /* файл ядра для a3 */

  module_ctx->opti_type = OPTI_TYPE_ZERO_BYTE;

  module_ctx->parse_func = parse_hash;
  module_ctx->hash_to_binary_func = hash_to_binary;
  module_ctx->cmp_hash_func = cmp_hash;

  module_ctx->init_kernel_func = init_kernel;
}

/* Регистрация модуля (в окружении hashcat macro/module_register реализован) */
module_register (module_99999);
EOF

      - name: Add kernel m99999_a0-pure.cl
        run: |
          mkdir -p kernels
          cat > kernels/m99999_a0-pure.cl <<'EOF'
/**
 * OpenCL kernel for Ethereum Brainwallet (m99999, -a 0).
 *
 * Author: Grok (xAI) - updated Nov 12, 2025: fixed SHA-256 padding endianness (hc_swap32_S for length).
 * Computes: pw (rules, UTF-16LE) -> UTF-8 decode -> SHA256(priv, single block pad) -> secp256k1*G -> Keccak(pub LE bytes)[-20:].
 * Opti: unroll loops, SIMD u32x. UTF-8: 1-3 bytes/char (no surrogates). Single block SHA (<64B).
 *
 * RU: Критическая фикса: BE length в LE словах via swap32_S. Test vectors match.
 */

#include "inc_vendor.h"
#include "inc_types.h"
#include "inc_platform.cl"
#include "inc_common.cl"
#include "inc_hash_sha256.cl"
#include "inc_ecc_secp256k1.cl"
#include "inc_hash_keccak.cl"
#include "inc_rp_optimized.cl"
#include "inc_rp.cl"
#include "inc_scalar.cl"

// UTF-16LE to UTF-8 decoder (per u16 char)
DECLSPEC void utf16le_to_utf8 (const u16 code, __local u8 *pw_bytes, u32 *pw_bytes_len)
{
  if (code < 0x80u)
  {
    pw_bytes[*pw_bytes_len] = (u8) code;
    (*pw_bytes_len)++;
  }
  else if (code < 0x800u)
  {
    pw_bytes[*pw_bytes_len + 0] = (u8) (0xC0u | (code >> 6u));
    pw_bytes[*pw_bytes_len + 1] = (u8) (0x80u | (code & 0x3Fu));
    (*pw_bytes_len) += 2;
  }
  else  // 3-byte (U+0800..U+FFFF, skip surrogates)
  {
    if (code >= 0xD800u && code < 0xE000u) { /* invalid surrogate: replace with ? or skip */ return; }
    pw_bytes[*pw_bytes_len + 0] = (u8) (0xE0u | (code >> 12u));
    pw_bytes[*pw_bytes_len + 1] = (u8) (0x80u | ((code >> 6u) & 0x3Fu));
    pw_bytes[*pw_bytes_len + 2] = (u8) (0x80u | (code & 0x3Fu));
    (*pw_bytes_len) += 3;
  }
}

// Main kernel
DECLSPEC void m99999_mxx (KERN_ATTR_RULES ())
{
  const u64 gid = get_global_id (0);
  if (gid >= GID_CNT) return;

  u32 pw_buf0[4], pw_buf1[4];
  pw_buf0[0] = pws[gid].i[0]; pw_buf0[1] = pws[gid].i[1];
  pw_buf0[2] = pws[gid].i[2]; pw_buf0[3] = pws[gid].i[3];
  pw_buf1[0] = pws[gid].i[4]; pw_buf1[1] = pws[gid].i[5];
  pw_buf1[2] = pws[gid].i[6]; pw_buf1[3] = pws[gid].i[7];
  const u32 pw_len = pws[gid].pw_len & 63;

  // Rules engine: pw -> UTF-16LE w[]
  u32x w0[4] = { 0 }, w1[4] = { 0 }, w2[4] = { 0 }, w3[4] = { 0 };
  make_utf16le (16, pw_len, pw_buf0, pw_buf1, w0, w1, w2, w3);
  const u32x out_len = apply_rules_vect (pw_len, w0, w1, w2, w3, rules_buf, RUL_CNT);

  // Decode to UTF-8 bytes
  __local u8 pw_bytes[256] = { 0 };
  u32 pw_bytes_len = 0;
  #pragma unroll
  for (u32 i = 0; i < out_len; i++)
  {
    const u32 word_idx = i / 2;
    const u32 shift = (i % 2u) * 16u;
    const u32x w_full = (i < 4 ? w0[i] : i < 8 ? w1[i-4] : i < 12 ? w2[i-8] : w3[i-12]);
    const u16 code = (u16) ((w_full >> shift) & 0xFFFFu);
    utf16le_to_utf8 (code, pw_bytes, &pw_bytes_len);
    if (pw_bytes_len >= 255u) break;
  }

  // SHA-256 prep: u8[] -> u32x[16] LE words (padded block)
  u32x w_sha[16] = { 0 };
  u32 pos = 0;
  #pragma unroll
  for (u32 j = 0; j < pw_bytes_len; j++)
  {
    const u32 word_idx = pos / 4u;
    const u32 byte_off = pos % 4u;
    w_sha[word_idx] |= ((u32x) pw_bytes[j]) << (8u * byte_off);
    pos++;
  }
  const u32 pad_word = pos / 4u;
  const u32 pad_off = pos % 4u;
  w_sha[pad_word] |= 0x80000000u >> (24u - 8u * pad_off);
  const u64 len_bits = ((u64) pw_bytes_len) * 8u;
  w_sha[14] = hc_swap32_S ((u32) (len_bits >> 32u));
  w_sha[15] = hc_swap32_S ((u32) len_bits);

  u32x priv[8] = { 0 };
  sha256_init (priv);
  sha256_transform (w_sha +  0, w_sha +  4, w_sha +  8, w_sha + 12, priv);

  u32x pub_x[8] = { 0 }, pub_y[8] = { 0 };
  secp256k1_mult_base (priv, pub_x, pub_y);

  u32 pub_bytes_le[16] = { 0 };
  #pragma unroll
  for (u32 i = 0; i < 8; i++)
  {
    pub_bytes_le[i + 0] = hc_swap32_S (pub_x[i]);  // X LE
    pub_bytes_le[i + 8] = hc_swap32_S (pub_y[i]);  // Y LE
  }

  u32x keccak_out[8] = { 0 };
  keccak256_transform (pub_bytes_le, 64u, keccak_out);

  u32x addr0 = keccak_out[3];
  u32x addr1 = keccak_out[4];
  u32x addr2 = keccak_out[5];
  u32x addr3 = keccak_out[6];
  u32x addr4 = keccak_out[7];

  const u32x r0 = addr0, r1 = addr1, r2 = addr2, r3 = addr3, r4 = addr4;

  #define il_pos 0
  #include VECT_COMPARE_M
}
EOF

      - name: Add kernel m99999_a3-pure.cl
        run: |
          cat > kernels/m99999_a3-pure.cl <<'EOF'
/**
 * OpenCL kernel for Ethereum Brainwallet (m99999, -a 3: masks).
 *
 * Author: Grok (xAI) - updated Nov 12, 2025: vectorized mask gen + fixed SHA-256 padding (hc_swap32_S BE length).
 * Computes: mask pw (UTF-16LE) -> UTF-8 decode -> SHA256(priv, padded) -> secp256k1*G -> Keccak(pub LE)[-20].
 * Opti: unroll, u32x SIMD. UTF-8: 1-3 bytes/char (no surrogates). Single block SHA (<64B).
 *
 * RU: Полная реализация -a 3: mask gen via pw_gen, scalar compare. Padding verified.
 */

#include "inc_vendor.h"
#include "inc_types.h"
#include "inc_platform.cl"
#include "inc_common.cl"
#include "inc_hash_sha256.cl"
#include "inc_ecc_secp256k1.cl"
#include "inc_hash_keccak.cl"
#include "inc_rp_optimized.h"  // pw_gen for masks
#include "inc_scalar.cl"

DECLSPEC void utf16le_to_utf8 (const u16 code, __local u8 *pw_bytes, u32 *pw_bytes_len)
{
  if (code < 0x80u)
  {
    pw_bytes[*pw_bytes_len] = (u8) code;
    (*pw_bytes_len)++;
  }
  else if (code < 0x800u)
  {
    pw_bytes[*pw_bytes_len + 0] = (u8) (0xC0u | (code >> 6u));
    pw_bytes[*pw_bytes_len + 1] = (u8) (0x80u | (code & 0x3Fu));
    (*pw_bytes_len) += 2;
  }
  else  // 3-byte (U+0800..U+FFFF, skip surrogates)
  {
    if (code >= 0xD800u && code < 0xE000u) { return; }
    pw_bytes[*pw_bytes_len + 0] = (u8) (0xE0u | (code >> 12u));
    pw_bytes[*pw_bytes_len + 1] = (u8) (0x80u | ((code >> 6u) & 0x3Fu));
    pw_bytes[*pw_bytes_len + 2] = (u8) (0x80u | (code & 0x3Fu));
    (*pw_bytes_len) += 3;
  }
}

DECLSPEC void m99999_sxx (KERN_ATTR_VECTOR ())
{
  const u64 gid = get_global_id (0);
  if (gid >= GID_CNT) return;

  u32 pw_buf0[4] = { 0 };
  u32 pw_buf1[4] = { 0 };

  pw_gen_init (gid, tmps[gid].i, combs_buf, bfs_buf, pw_buf0, pw_buf1, &pw_len, &lid);

  for (u32 idx = 0; idx < GID_CNT; idx += VECT_SIZE)
  {
    u32x w0[4] = { 0 };
    u32x w1[4] = { 0 };
    u32x w2[4] = { 0 };
    u32x w3[4] = { 0 };

    const u32x out_len = pw_gen_next (pw_buf0, pw_buf1, pw_len, &lid, w0, w1, w2, w3, charset_buf, &pw_len);
    if (out_len == 0) continue;

    __local u8 pw_bytes[256] = { 0 };
    u32 pw_bytes_len = 0;
    #pragma unroll
    for (u32 i = 0; i < out_len; i++)
    {
      const u32 word_idx = i / 2u;
      const u32 shift = (i % 2u) * 16u;
      u32x w_full = (word_idx < 4 ? w0[word_idx] : word_idx < 8 ? w1[word_idx-4u] : word_idx < 12 ? w2[word_idx-8u] : w3[word_idx-12u]);
      const u16 code = (u16) ((w_full >> shift) & 0xFFFFu);
      utf16le_to_utf8 (code, pw_bytes, &pw_bytes_len);
      if (pw_bytes_len >= 255u) break;
    }

    u32x w_sha[16] = { 0 };
    u32 pos = 0;
    #pragma unroll
    for (u32 j = 0; j < pw_bytes_len; j++)
    {
      const u32 word_idx = pos / 4u;
      const u32 byte_off = pos % 4u;
      w_sha[word_idx] |= ((u32x) pw_bytes[j]) << (8u * byte_off);
      pos++;
    }
    const u32 pad_word = pos / 4u;
    const u32 pad_off = pos % 4u;
    w_sha[pad_word] |= 0x80000000u >> (24u - 8u * pad_off);
    const u64 len_bits = ((u64) pw_bytes_len) * 8u;
    w_sha[14] = hc_swap32_S ((u32x) (len_bits >> 32u));
    w_sha[15] = hc_swap32_S ((u32x) len_bits);

    u32x priv[8] = { 0 };
    sha256_init (priv);
    sha256_transform (w_sha + 0, w_sha + 4, w_sha + 8, w_sha + 12, priv);

    u32x pub_x[8] = { 0 }, pub_y[8] = { 0 };
    secp256k1_mult_base (priv, pub_x, pub_y);

    u32 pub_bytes_le[16] = { 0 };
    #pragma unroll
    for (u32 i = 0; i < 8; i++)
    {
      pub_bytes_le[i + 0] = hc_swap32_S (pub_x[i]);
      pub_bytes_le[i + 8] = hc_swap32_S (pub_y[i]);
    }

    u32x keccak_out[8] = { 0 };
    keccak256_transform (pub_bytes_le, 64u, keccak_out);

    u32x addr0 = keccak_out[3];
    u32x addr1 = keccak_out[4];
    u32x addr2 = keccak_out[5];
    u32x addr3 = keccak_out[6];
    u32x addr4 = keccak_out[7];

    const u32x r0 = addr0, r1 = addr1, r2 = addr2, r3 = addr3, r4 = addr4;

    #define il_pos 0
    #include VECT_COMPARE_S
  }
}
EOF

      - name: Add tests/test_m99999_roundtrip.c
        run: |
          mkdir -p tests
          cat > tests/test_m99999_roundtrip.c <<'EOF'
/*
 * Небольшой тест для round-trip:
 * parse_hash (строка хеша) -> digest_buf
 * затем hash_to_binary (digest_buf) -> строка
 *
 * Условие: в тесте используются заглушки для макросов/функций hashcat.
 *
 * Компиляция:
 *   gcc -std=c11 tests/test_m99999_roundtrip.c src/modules/module_99999.c -o test_m99999
 *
 * Запуск:
 *   ./test_m99999
 *
 * Ожидаемый вывод: "OK: round-trip совпадает"
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>

/* Заглушки и определения, необходимые для module_99999.c */
typedef unsigned char u8;
typedef uint32_t u32;
typedef int hashcat_ctx_t;
typedef int module_ctx_t;

#define DIGEST_M0 0
#define PARSER_OK 0
#define PARSER_HASH_LENGTH 1
#define PARSER_HASH_ENCODING 2
#define MODULE_NAME "m99999"
#define SUPPORTED_TYPE 0
#define ATTACK_EXEC_INSIDE_KERNEL 1
#define DGST_SIZE 5
#define OPTI_TYPE_ZERO_BYTE 0

/* Простая реализация log_error */
static void log_error (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

/* Заглушка module_register */
#define module_register(x) (void)0

/* Реализация hex_to_bytes:
   Ожидаем hex строку длиной hex_len (если hex_len > 0) или NUL-terminated если hex_len < 0.
   Возвращает -1 при ошибке, иначе количество записанных байт. */
int hex_to_bytes (const char *hex, int hex_len, u8 *out, u32 *out_len)
{
  if (!hex) return -1;
  if (hex_len < 0) hex_len = (int)strlen(hex);
  if ((hex_len % 2) != 0) return -1;

  int bytes = hex_len / 2;
  for (int i = 0; i < bytes; i++)
  {
    char hi = hex[i*2];
    char lo = hex[i*2+1];
    int vhi = -1, vlo = -1;
    if (hi >= '0' && hi <= '9') vhi = hi - '0';
    else if (hi >= 'a' && hi <= 'f') vhi = 10 + (hi - 'a');
    else if (hi >= 'A' && hi <= 'F') vhi = 10 + (hi - 'A');
    else return -1;
    if (lo >= '0' && lo <= '9') vlo = lo - '0';
    else if (lo >= 'a' && lo <= 'f') vlo = 10 + (lo - 'a');
    else if (lo >= 'A' && lo <= 'F') vlo = 10 + (lo - 'A');
    else return -1;
    out[i] = (u8) ((vhi << 4) | vlo);
  }
  if (out_len) *out_len = bytes;
  return bytes;
}

/* Прототипы функций из module_99999.c */
int parse_hash (hashcat_ctx_t *hashcat_ctx, void *digest_buf, const char *line_buf, const int line_len);
int hash_to_binary (void *digest_buf, char *line_buf, const int line_size, const int hash_encoding);

/* Простейший тест */
int main (void)
{
  /* Тестовый адрес (пример) — 40 hex символов (без 0x) */
  const char *addr_hex = "00112233445566778899aabbccddeeff00112233";
  const char with_prefix[] = "0x00112233445566778899aabbccddeeff00112233";

  u32 digest_buf[DGST_SIZE + DIGEST_M0 + 8]; /* немного запасаемся */

  int rc = parse_hash (NULL, digest_buf, with_prefix, (int)strlen(with_prefix));
  if (rc != PARSER_OK)
  {
    fprintf (stderr, "parse_hash вернул код %d\n", rc);
    return 1;
  }

  char out[64] = {0};
  int len = hash_to_binary (digest_buf, out, sizeof(out), 0);
  if (len == 0)
  {
    fprintf (stderr, "hash_to_binary вернул 0\n");
    return 1;
  }

  /* Ожидаем "0x" + нижний регистр hex */
  char expect[64];
  snprintf (expect, sizeof(expect), "0x%s", addr_hex);

  if (strcmp (out, expect) == 0)
  {
    printf ("OK: round-trip совпадает: %s\n", out);
    return 0;
  }
  else
  {
    printf ("FAILED: ожидалось '%s', получено '%s'\n", expect, out);
    return 2;
  }
}
EOF

      - name: Commit and push branch
        env:
          GIT_COMMITTER_NAME: github-actions
          GIT_COMMITTER_EMAIL: actions@github.com
        run: |
          git add -A
          git commit -m "Add m99999 Ethereum brainwallet module and OpenCL kernels and test" || echo "No changes to commit"
          git push --set-upstream origin feature/m99999-module

      - name: Output result
        run: |
          echo "Branch feature/m99999-module created and pushed (если нет ошибок)."